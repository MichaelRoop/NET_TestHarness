using System;
using System.Collections.Generic;
using System.Text;
using Ca.Roop.TestHarness.Core.Test;
using Ca.Roop.TestHarness.Engine;
using Ca.Roop.TestHarness.Logs;
using Ca.Roop.TestHarness.Logs.RowBuilders;
using Ca.Roop.TestHarness.TestExceptions;

namespace Ca.Roop.TestHarness.Core
{

/// <summary>Pure virtual base class for all test cases.</summary>
/// <remarks>
/// This class encapsulates performance logging of each stage of the test.  As well, it
/// tracks the state and holds test information generated by the derived tests.
///
/// The test case object can be querried by the logger derived objects to assemble the 
/// information required.
///
/// Test case objects are constructed with a unique id string which is used to identify
/// and retrieve the test.  It is also constructed with a description string.
///
/// When the test case is retrieved, the arguments can be fed to it by means of the init
/// method.
///
/// There are three stages to a test case, the setup, the test, and the cleanup.
/// </remarks>
public abstract class TestCase : ITestable {

    private string	        desc;
    private Int64           initTime;
    private Int64           setupTime;
    private Int64           execTime;
    private Int64			cleanupTime;

    private TestStatus      _status;
    private String          _id;
    private StringBuilder   _msgBuffer;
    private StringBuilder   _verboseBuffer;


    /// <see cref="ITestable.Status."/>
    public TestStatus Status { get { return _status; } protected set { _status = value; } }		
	
    /// <see cref="ITestable.Id."/>
    public String Id { get { return _id; } private set { _id = value; } }

    /// <see cref="ITestable.MsgBuffer."/>
    public StringBuilder MsgBuffer { get { return _msgBuffer; } private set { _msgBuffer = value; } }


    /// <see cref="ITestable.VerboseBuffer."/>
    public StringBuilder VerboseBuffer { 
        get { 
            return _verboseBuffer; 
        } 
        private set { 
            _verboseBuffer = value; 
        } 
    }


    /// <summary>The Test case argument list.</summary>
    protected List<TestArg>   Args {get; private set;}


    // Protected default constructor to force use of regular constructor.
    private TestCase() {
    }


    // Protected copy constructor to force use of regular constructor.
    private TestCase(TestCase c) {
    }


    /// <summary>Constructor</summary>
    /// <param name="id">Unique identifier for the test.</param>
    /// <param name="desc">Test description.</param>
    public TestCase(string id, string desc) {
        this.Id             = id;
        this.desc           = desc;
        this.initTime       = 0;
        this.setupTime      = 0;
        this.execTime       = 0;
        this.cleanupTime    = 0;
        this.MsgBuffer      = new StringBuilder("", 100);
        this.VerboseBuffer  = new StringBuilder("",200);
        this.Args           = new List<TestArg>();

    }


    /// <summary>
    /// Initialise method for two phase construction. This is fed into the test case by 
    /// the engine just before the setup is called.
    /// </summary>
    /// <returns>true if successful, otherwise false.</returns>
    public virtual bool Init() {
        return true;
    }


    /// <summary>
    /// Override to setup test before test is run in test method. Default returns true.
    /// </summary>
    /// <returns>true if successful, otherwise false.</returns>
    public virtual bool Setup() {
        return true;
    }


    /// <summary>Override to execute test.</summary>
    /// <returns>true if successful, otherwise false.</returns>
    public abstract bool Test();


    /// <summary>Override to clean up after test is run. Default returns true.</summary>
    /// <returns>true if successful, otherwise false.</returns>
    public virtual bool Cleanup() {
        return true;
    }


    /// <summary>Called by the engine when the test is selected.</summary>
    /// <remarks>
    ///	Allows the test to be created before the arguments for the test are known. In this
    /// way a test case code can be used in different ways depending on the arguments that
    /// are read in at select time.  Part of the arguments can also be expected return value.
    ///
    /// The test is instantiated and stored.  When it is selected, the arguments are know from 
    /// the same script from which is was selected.
    /// </remarks>
    /// <param name="args">A list of arguments for the test.</param>
    /// <returns>true if successful, otherwise false.</returns>
    public bool ExecuteInit(List<TestArg> args) {
        if (this.Status != TestStatus.NOT_EXISTS) {
            this.Reset(args);
            return this.SetStatus(
                TestCaseTimer.Time(this.Init, ref this.initTime, ref this._status, this),
                TestStatus.FAIL_INIT);
        }
        return false;
    }


    /// <summary>Executes and times the test setup.</summary>
    /// <returns>true if successful, otherwise false.</returns>
    public bool ExecuteSetup() {
        if (this.Status == TestStatus.SUCCESS) {
            return this.SetStatus(
                TestCaseTimer.Time(this.Setup, ref this.setupTime, ref this._status, this),
                TestStatus.FAIL_SETUP);
        }
        return false;
    }


    /// <summary>Executes and times the test itself.</summary>
    /// <returns>true if successful, otherwise false.</returns>
    public bool ExecuteTest() {
        if (this.Status == TestStatus.SUCCESS) {
            return this.SetStatus(
                TestCaseTimer.Time(this.Test, ref this.execTime, ref this._status, this),
                TestStatus.FAIL_TEST);
        }
        return false;
    }


    /// <summary>Executes and times the test cleanup.</summary>
    /// <returns>true if successful, otherwise false.</returns>
    public bool ExecuteCleanup() {
        // Cleanup always executed.
        bool ret = TestCaseTimer.Time(this.Cleanup, ref this.cleanupTime, ref this._status, this);

        // Failure on cleanup will only be logged if all else was successful.
        if (this.Status == TestStatus.SUCCESS) {
            this.SetStatus(ret, TestStatus.FAIL_CLEANUP);
        }
        return ret;

        //return this.ExecStep(ref this.cleanupTime, TestStatus.FAIL_CLEANUP, this.Cleanup);
    }


    /// <summary>
    /// Implements the ILogable interface GetValue.  This allows the object to be queried for 
    /// its values.
    /// </summary>
    /// <param name="columnDef">Column metadata.</param>
    /// <param name="info">Log metadata</param>
    /// <returns>The string representation of the queried data field.</returns>
	public String GetValue(ColumnDef columnDef, LogInfo info) {
        if (columnDef.Name.CompareTo("Identifier") == 0) {
            return this.WrapStringData(this.Id, columnDef, info);
		}
		else if (columnDef.Name.CompareTo("Description") == 0) {
            return this.WrapStringData(this.desc, columnDef, info);
		}
        else if (columnDef.Name.CompareTo("Status") == 0) {
            return this.WrapStringData(this.Status.ToString(), columnDef, info);
		}
        else if (columnDef.Name.CompareTo("Message") == 0) {
            return this.WrapStringData(this.MsgBuffer.ToString(), columnDef, info);
		}
        else if (columnDef.Name.CompareTo("InitTime") == 0) {
			return Convert.ToString(this.initTime);
		}
        else if (columnDef.Name.CompareTo("SetupTime") == 0) {
			return Convert.ToString(this.setupTime);
		}
        else if (columnDef.Name.CompareTo("ExecTime") == 0) {
			return Convert.ToString(this.execTime);
		}
        else if (columnDef.Name.CompareTo("CleanupTime") == 0) {
			return Convert.ToString(this.cleanupTime);
		}
        else if (columnDef.Name.CompareTo("RunId") == 0) {
            // Do NOT truncate run id or output could be useless as identifier. Better let it to fail.
            return new StringBuilder()
                .Append(info.SyntaxData.StringDelimiter)
                .Append(TestEngine.GetInstance().GetRunId())
                .Append(info.SyntaxData.StringDelimiter).ToString();
		}
        else if (columnDef.Name.CompareTo("VerboseMessage") == 0) {
            return this.BuildVerboseBufferStr(columnDef, info);
		}
		else 
		{
			StringBuilder sb = new StringBuilder( 200 );
			sb.Append("Illegal column name:").Append(columnDef.Name)
                .Append(" - Allowable values are:")
                .Append("ID, Description, Status, InitTime,SetupTime, ExecTime, CleanupTime, RunId Message, VerboseMessage");
			throw new InputException(sb.ToString());

            // TODO - Replace with our own exceptions.
            throw new System.ArgumentException(sb.ToString());
		}
	}


    /// <summary>Retrieve the argument object by name</summary>
    /// <param name="name">Name of the argument.</param>
    /// <returns>The named argument.</returns>
    /// <exception cref="ArgumentException" />
    protected TestArg RetrieveNamedArg(String name) {
        foreach (TestArg a in this.Args) {
            if (a.Name.CompareTo(name) == 0) {
                return a;
            }
        }
        throw new ArgumentException("Named Arg not found", name);
    }


    /// <summary>Verifies if the names argument exists.</summary>
    /// <param name="name">The argument name.</param>
    /// <returns>true if the argument is present, otherwise false.</returns>
    protected bool HasNamedArg(String name) {
        foreach (TestArg a in this.Args) {
            if (a.Name.CompareTo(name) == 0) {
                return true;
            }
        }
        return false;
    }


    /// <summary>Try to retrieve the argument object by name</summary>
    /// <param name="name">Name of the argument.</param>
    /// <param name="arg">The TestArg object to intialise if name match is found.</param>
    /// <returns>true if found, otherwise false.</returns>
    protected bool TryRetrieveNamedArg(String name, out TestArg arg) {
        foreach (TestArg a in this.Args) {
            if (a.Name.CompareTo(name) == 0) {
                arg = a;
                return true;
            }
        }
        arg = null;
        return false;
    }


    private string TrimToSize(string str, ColumnDef columnDef) {
        if (columnDef.IsDataToBeTruncated()) {
            if (str.Length > columnDef.MaxLength) {
                return str.Substring(0, columnDef.MaxLength);
            }
        }
        return str;
    }


    // Wrap string data in string delimiters quotes.
    private string WrapStringData(string str, ColumnDef columnDef, LogInfo info) {
        return new StringBuilder(25)
            .Append(info.SyntaxData.StringDelimiter)
            .Append(this.TrimToSize(str, columnDef))
            .Append(info.SyntaxData.StringDelimiter).ToString();
    }


    // Assemble the verbose buffer message. 
    private string BuildVerboseBufferStr(ColumnDef columnDef, LogInfo info) {
        //TODO Look at moving this to an output level object.
        StringBuilder sb = new StringBuilder();
        sb.Append(info.SyntaxData.StringDelimiter);
        if (this.VerboseBuffer.Length > 0)
        {
            StringBuilder tmpSb = new StringBuilder();
            tmpSb.Append(info.OutputData.NewLineSequence)
                .Append("-----------------------------------").Append(info.OutputData.NewLineSequence)
                .Append(this.VerboseBuffer.ToString())
                .Append(info.OutputData.NewLineSequence);
            sb.Append(this.TrimToSize(tmpSb.ToString(), columnDef));
        }
        return sb.Append(info.SyntaxData.StringDelimiter).ToString();
    }


    /// <summary>Helper method to set the status.</summary>
    /// <param name="isOk">The status of the current test.</param>
    /// <param name="failStatus">The status to set upon failure.</param>
    /// <returns>The same status as the argument isOk.</returns>
    private bool SetStatus(bool isOk, TestStatus failStatus) {
        // Special case - When the State is Failed on exception you 
        // must not reset the state. It supercedes all other state changes.
        if (this.Status != TestStatus.FAIL_BY_EXCEPTION) {
            this.Status = (isOk == true ? TestStatus.SUCCESS : failStatus);
        }
        return isOk;
    }


    private void Reset(List<TestArg> args) {
        this.MsgBuffer.Remove(0, this.MsgBuffer.Length);
        this.VerboseBuffer.Remove(0, this.VerboseBuffer.Length);
        this.Args = args;
    }

}


} // end namespace.

  



